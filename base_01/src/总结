react:
1.组件的类型 (函数型/class型/pureComponnt/高阶组件)
2.生命周期
flux:
  View:视图层
  Action:动作,视图发出消息
  Dispatcher:派发器,用来接收Action,执行回调函数的
  Store:数据层,用来存放状态,一旦发生变动,提醒views要更新页面


用户访问view-->view发出用户的Action-->Dispatcher接收Action要求Store做出相应的更新-->
Store更新后,发出一个change事件-->view收到change事件后,更新页面

redux:
1.设计思想
  （1）Web 应用是一个状态机，视图与状态是一一对应的。
  （2）所有的状态，保存在一个对象里面。
2.本概念和 API
  2.1 Store:保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store
      Redux 提供createStore这个函数，用来生成 Store
  2.2 State:Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。
      当前时刻的 State，可以通过store.getState()拿到。
      一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然
  2.3 Action:View 发出的通知，表示State应该要发生变化了Action是一个对象。其中的type属性是必须的，
  表示Action的名称。其他属性可以自由设置
      Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。
      const action = {
        type: 'ADD_TODO',
        payload: 'Learn Redux'
      }
      上面代码中，Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux。
  2.4  store.dispatch():View 发出 Action 的唯一方法
        import { createStore } from 'redux';
        const store = createStore(fn);

        store.dispatch({
          type: 'ADD_TODO',
          payload: 'Learn Redux'
        });
  store.dispatch接受一个 Action 对象作为参数，将它发送出去

  2.5 reducer:Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。
  这种 State 的计算过程就叫做 Reducer。
    Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。
      const defaultState = 0;
      const reducer = (state = defaultState, action) => {
        switch (action.type) {
          case 'ADD':
            return state + action.payload;
          default: 
            return state;
        }
      };

      const state = reducer(1, {
        type: 'ADD',
        payload: 2
      });
    上面代码中，reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果。
    其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。
    实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。
    为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。


    import { createStore } from 'redux';
    const store = createStore(reducer);
   上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，
   就会自动调用 Reducer，得到新的 State。

   Reducer 函数里面不能改变 State，必须返回一个全新的对象

   2.6 store.subscribe()
   Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数
   store.subscribe方法返回一个函数，调用这个函数就可以解除监听。

   let unsubscribe = store.subscribe(() =>
      console.log(store.getState())
    );
    unsubscribe();

  redux的流程:
  用户发出Action store.dispatch(action)  -->   store自动调用reducer,并传入两个参数:当前state和收到的Action,
  reducer会返回新的state --> state一旦有新的变化,Store就会调用监听函数store.dispatch(listener) 
  ---> listener可以通过store.getState()得到当前的状态,若是react,则会触发重新渲染view

  redux中间件:
  一个关键问题没有解决：异步操作怎么办？Action 发出以后，Reducer 立即算出 State，这叫做同步；
  Action 发出以后，过一段时间再执行 Reducer，这就是异步。
  怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：中间件（middleware）。

  
      